<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <title>å°ˆæ¥­ UI ç¤ºæ„åœ–ç”¢ç”Ÿå™¨</title>
    <style>
      :root {
        --primary: #4a90e2;
        --success: #27ae60;
      }
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 20px;
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .container {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        max-width: 1000px;
        width: 100%;
      }
      .controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }
      .control-group {
        display: flex;
        flex-direction: column;
      }
      label {
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 5px;
        color: #555;
      }
      input,
      textarea,
      select {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
      }
      .button-group {
        grid-column: 1 / -1;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        justify-content: center;
        padding-top: 10px;
        border-top: 1px solid #eee;
      }
      button {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: bold;
        transition: 0.2s;
      }
      .btn-main {
        background: var(--primary);
        color: white;
      }
      .btn-copy {
        background: var(--success);
        color: white;
      }
      .btn-download {
        background: #34495e;
        color: white;
      }
      button:hover {
        opacity: 0.9;
        transform: translateY(-1px);
      }
      canvas {
        border: 1px solid #333;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        background: white;
        max-width: 100%;
        height: auto;
        cursor: crosshair;
      }
      .hint {
        font-size: 12px;
        color: #888;
        text-align: center;
        margin-top: 10px;
      }
      #copyStatus {
        font-weight: normal;
        margin-left: 8px;
        transition: 0.3s;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="controls">
        <div class="control-group" style="grid-column: span 2">
          <label>æ¨™é¡Œæ–‡å­—</label>
          <textarea id="textInput" rows="2">New UI Mockup</textarea>
        </div>
        <div class="control-group">
          <label>ç•«å¸ƒå°ºå¯¸</label>
          <select id="sizePreset" onchange="applyPreset(this.value)">
            <option value="480x270">480x270</option>
            <option value="640x360">640x360</option>
            <option value="854x480">854x480</option>
            <option value="960x540">960x540</option>
            <option value="1280x720">1280x720</option>
            <option value="1920x1080">Desktop (1920x1080)</option>
            <option value="1600x900">1600x900</option>
            <option value="1080x1920">Mobile (1080x1920)</option>
            <option value="1080x1080">Square (1:1)</option>
            <option value="custom">è‡ªå®šç¾©</option>
          </select>
        </div>
        <div class="control-group">
          <label>å¯¬ x é«˜</label>
          <div style="display: flex; gap: 5px">
            <input
              type="number"
              id="widthInput"
              value="480"
              style="width: 50%"
            />
            <input
              type="number"
              id="heightInput"
              value="270"
              style="width: 50%"
            />
          </div>
        </div>
        <div class="control-group">
          <label>å­—é«”å¤§å° / é¡è‰²</label>
          <div style="display: flex; gap: 5px">
            <input
              type="number"
              id="fontSizeInput"
              value="46"
              style="width: 50%"
            />
            <input
              type="color"
              id="textColorInput"
              value="#333333"
              style="width: 50%"
            />
          </div>
        </div>
        <div class="control-group">
          <label>èƒŒæ™¯é¡è‰²</label>
          <div style="display: flex; align-items: center; gap: 5px">
            <input type="color" id="bgColorInput" value="#f0f2f5" />
            <label style="margin: 0; font-weight: normal"
              ><input type="checkbox" id="randomBgCheckbox" /> éš¨æ©Ÿ</label
            >
          </div>
        </div>

        <div class="button-group">
          <button class="btn-main" onclick="generateBase()">
            é‡æ–°ç”¢ç”ŸèƒŒæ™¯
          </button>
          <button class="btn-copy" onclick="copyToClipboard()">
            è¤‡è£½åˆ°å‰ªè²¼ç°¿<span id="copyStatus"></span>
          </button>
          <button class="btn-download" onclick="downloadImage()">
            ä¸‹è¼‰åœ–ç‰‡ (PNG)
          </button>
        </div>
      </div>

      <canvas id="myCanvas"></canvas>
      <p class="hint">
        ğŸ’¡ æŠ€å·§ï¼šæ‹–æ›³åœ–ç‰‡é€²ä¾†ã€é»é¸å¾ŒæŒ‰ Delete åˆªé™¤ã€ç§»å‹•æ™‚æœƒè‡ªå‹•å¸é™„ä¸­å¿ƒé»
      </p>
    </div>

    <script>
      const canvas = document.getElementById("myCanvas");
      const ctx = canvas.getContext("2d");
      let baseImageData = null;
      const overlayImages = [];
      let selectedImage = null,
        draggingImage = null,
        resizingImage = null;
      let dragOffsetX = 0,
        dragOffsetY = 0;
      let showGuideX = false,
        showGuideY = false;

      // åˆå§‹åŒ–èˆ‡äº‹ä»¶ç¶å®š
      window.onload = () => {
        generateBase();
        const autoUpdateIds = [
          "textInput",
          "widthInput",
          "heightInput",
          "fontSizeInput",
          "bgColorInput",
          "textColorInput",
        ];
        autoUpdateIds.forEach((id) =>
          document.getElementById(id).addEventListener("input", generateBase),
        );
      };

      function applyPreset(val) {
        if (val === "custom") return;
        const [w, h] = val.split("x");
        document.getElementById("widthInput").value = w;
        document.getElementById("heightInput").value = h;
        generateBase();
      }

      function getRandomColor() {
        return `hsl(${Math.floor(Math.random() * 360)}, 60%, 85%)`;
      }

      function generateBase() {
        const text = document.getElementById("textInput").value || "";
        const w = parseInt(document.getElementById("widthInput").value) || 1920;
        const h =
          parseInt(document.getElementById("heightInput").value) || 1080;
        const fontSize =
          parseInt(document.getElementById("fontSizeInput").value) || 100;
        const bgColor = document.getElementById("randomBgCheckbox").checked
          ? getRandomColor()
          : document.getElementById("bgColorInput").value;

        canvas.width = w;
        canvas.height = h;

        // ç¹ªè£½èƒŒæ™¯
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, w, h);

        // ç¹ªè£½è£é£¾é‚Šæ¡†
        ctx.strokeStyle = "rgba(0,0,0,0.05)";
        ctx.lineWidth = 40;
        ctx.strokeRect(20, 20, w - 40, h - 40);

        // ç¹ªè£½æ–‡å­—
        ctx.fillStyle = document.getElementById("textColorInput").value;
        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const lines = text.split("\n");
        const lineHeight = fontSize * 1.2;
        const totalH = lines.length * lineHeight;
        lines.forEach((line, i) => {
          ctx.fillText(
            line,
            w / 2,
            h / 2 - totalH / 2 + lineHeight / 2 + i * lineHeight,
          );
        });

        baseImageData = ctx.getImageData(0, 0, w, h);
        redraw();
      }

      function redraw() {
        if (!baseImageData) return;
        ctx.putImageData(baseImageData, 0, 0);

        // ç¹ªè£½å°é½Šè¼”åŠ©ç·š (ä¸­å¿ƒèˆ‡é‚Šç·£)
        if (showGuideX) {
          ctx.strokeStyle = "#e74c3c";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(canvas.width / 2, 0);
          ctx.lineTo(canvas.width / 2, canvas.height);
          ctx.stroke();
        }
        if (showGuideY) {
          ctx.strokeStyle = "#e74c3c";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height / 2);
          ctx.lineTo(canvas.width, canvas.height / 2);
          ctx.stroke();
        }

        overlayImages.forEach((img) => {
          ctx.drawImage(img.image, img.x, img.y, img.width, img.height);
          if (img === selectedImage) {
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = "#4a90e2";
            ctx.strokeRect(img.x, img.y, img.width, img.height);
            ctx.setLineDash([]);
            ctx.fillStyle = "#4a90e2";
            ctx.fillRect(
              img.x + img.width - 12,
              img.y + img.height - 12,
              12,
              12,
            );
          }
        });
      }

      // æ‹–æ”¾åœ–ç‰‡é‚è¼¯
      canvas.addEventListener("dragover", (e) => e.preventDefault());
      canvas.addEventListener("drop", (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          const reader = new FileReader();
          reader.onload = (evt) => {
            const img = new Image();
            img.onload = () => {
              const aspect = img.width / img.height;
              const nw = canvas.width * 0.3;
              overlayImages.push({
                image: img,
                x: (canvas.width - nw) / 2,
                y: (canvas.height - nw / aspect) / 2,
                width: nw,
                height: nw / aspect,
              });
              redraw();
            };
            img.src = evt.target.result;
          };
          reader.readAsDataURL(file);
        }
      });

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const scale = canvas.width / rect.width;
        const mx = (e.clientX - rect.left) * scale;
        const my = (e.clientY - rect.top) * scale;

        selectedImage = draggingImage = resizingImage = null;
        showGuideX = showGuideY = false;

        for (let i = overlayImages.length - 1; i >= 0; i--) {
          const img = overlayImages[i];
          // ç¸®æ”¾é»
          if (
            mx >= img.x + img.width - 15 &&
            mx <= img.x + img.width &&
            my >= img.y + img.height - 15 &&
            my <= img.y + img.height
          ) {
            resizingImage = img;
            selectedImage = img;
            return;
          }
          // æ‹–æ›³ä¸»é«”
          if (
            mx >= img.x &&
            mx <= img.x + img.width &&
            my >= img.y &&
            my <= img.y + img.height
          ) {
            draggingImage = img;
            selectedImage = img;
            dragOffsetX = mx - img.x;
            dragOffsetY = my - img.y;
            redraw();
            return;
          }
        }
        redraw();
      });

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const scale = canvas.width / rect.width;
        const mx = (e.clientX - rect.left) * scale;
        const my = (e.clientY - rect.top) * scale;

        if (resizingImage) {
          resizingImage.width = Math.max(30, mx - resizingImage.x);
          resizingImage.height =
            resizingImage.width *
            (resizingImage.image.height / resizingImage.image.width);
        } else if (draggingImage) {
          let nextX = mx - dragOffsetX;
          let nextY = my - dragOffsetY;

          // ç£å¸é‚è¼¯ (è·é›¢ä¸­å¿ƒ 20px å…§å¸é™„)
          const centerX = canvas.width / 2 - draggingImage.width / 2;
          const centerY = canvas.height / 2 - draggingImage.height / 2;

          showGuideX = Math.abs(nextX - centerX) < 20;
          if (showGuideX) nextX = centerX;

          showGuideY = Math.abs(nextY - centerY) < 20;
          if (showGuideY) nextY = centerY;

          draggingImage.x = nextX;
          draggingImage.y = nextY;
        }
        if (draggingImage || resizingImage) redraw();
      });

      canvas.addEventListener("mouseup", () => {
        draggingImage = resizingImage = null;
        showGuideX = showGuideY = false;
        redraw();
      });

      // åŠŸèƒ½éµ
      document.addEventListener("keydown", (e) => {
        if (
          (e.key === "Delete" || e.key === "Backspace") &&
          selectedImage &&
          document.activeElement.tagName !== "TEXTAREA"
        ) {
          overlayImages.splice(overlayImages.indexOf(selectedImage), 1);
          selectedImage = null;
          redraw();
        }
      });

      // è¤‡è£½èˆ‡ä¸‹è¼‰
      async function copyToClipboard() {
        const status = document.getElementById("copyStatus");
        canvas.toBlob(async (blob) => {
          try {
            const data = [new ClipboardItem({ [blob.type]: blob })];
            await navigator.clipboard.write(data);
            status.innerText = " âœ…";
            setTimeout(() => (status.innerText = ""), 1500);
          } catch (err) {
            alert("ç€è¦½å™¨ä¸æ”¯æ´ç›´æ¥è¤‡è£½åœ–ç‰‡ï¼Œè«‹å˜—è©¦å³éµå¦å­˜ã€‚");
          }
        });
      }

      function downloadImage() {
        const link = document.createElement("a");
        link.download =
          document.getElementById("textInput").value ||
          `mockup-${Date.now()}.png`;
        link.href = canvas.toDataURL();
        link.click();
      }
    </script>
  </body>
</html>
