<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Client Info Demo</title>
    <style>
      body {
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial;
        line-height: 1.45;
        padding: 20px;
        background: #f7f7fb;
        color: #111;
      }
      h1 {
        font-size: 1.25rem;
        margin-bottom: 0.5rem;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        background: #fff;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
      }
      th,
      td {
        padding: 10px;
        border: 1px solid #eef;
        vertical-align: top;
        font-family: monospace;
        font-size: 0.9rem;
      }
      th {
        width: 260px;
        background: #fafbfd;
        text-align: left;
      }
      .controls {
        margin: 12px 0;
        display: flex;
        gap: 8px;
      }
      button {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #d6dbe8;
        background: #fff;
        cursor: pointer;
      }
      pre {
        white-space: pre-wrap;
        word-break: break-word;
        margin: 0;
      }
      .small {
        font-size: 0.85rem;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h1>Client Info Demo</h1>
    <p class="small">
      此頁面會收集並顯示瀏覽器能取得的各項 client
      資訊。某些項目（例如地理位置或電池）需額外權限才會顯示。
    </p>

    <div class="controls">
      <button id="refreshBtn">刷新</button>
      <button id="geoBtn">取得地理位置（需允許）</button>
      <button id="copyBtn">複製 JSON</button>
      <button id="downloadBtn">下載 JSON 檔</button>
    </div>

    <table id="infoTable">
      <thead>
        <tr>
          <th>項目</th>
          <th>數值</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <script>
      async function getWebGLInfo() {
        try {
          const canvas = document.createElement("canvas");
          const gl =
            canvas.getContext("webgl") ||
            canvas.getContext("experimental-webgl");
          if (!gl) return { supported: false };
          const dbgRenderInfo = gl.getExtension("WEBGL_debug_renderer_info");
          const vendor = dbgRenderInfo
            ? gl.getParameter(dbgRenderInfo.UNMASKED_VENDOR_WEBGL)
            : gl.getParameter(gl.VENDOR);
          const renderer = dbgRenderInfo
            ? gl.getParameter(dbgRenderInfo.UNMASKED_RENDERER_WEBGL)
            : gl.getParameter(gl.RENDERER);
          return { supported: true, vendor, renderer };
        } catch (e) {
          return { supported: false, error: String(e) };
        }
      }

      async function getBattery() {
        if (navigator.getBattery) {
          try {
            const b = await navigator.getBattery();
            return {
              charging: b.charging,
              level: b.level,
              chargingTime: b.chargingTime,
              dischargingTime: b.dischargingTime,
            };
          } catch (e) {
            return { error: String(e) };
          }
        }
        return null;
      }

      function getUserAgentData() {
        // userAgentData is relatively new and may not exist in all browsers
        try {
          if (navigator.userAgentData) {
            return {
              brands:
                navigator.userAgentData.brands ||
                navigator.userAgentData.uaList ||
                null,
              mobile: navigator.userAgentData.mobile,
              highEntropy:
                typeof navigator.userAgentData.getHighEntropyValues ===
                "function",
            };
          }
        } catch (e) {}
        return null;
      }

      function getConnection() {
        try {
          const c =
            navigator.connection ||
            navigator.mozConnection ||
            navigator.webkitConnection;
          if (!c) return null;
          const obj = {};
          ["effectiveType", "downlink", "rtt", "type", "saveData"].forEach(
            (k) => {
              if (k in c) obj[k] = c[k];
            },
          );
          return obj;
        } catch (e) {
          return { error: String(e) };
        }
      }

      function getPermissionsSummary() {
        if (
          !navigator.permissions ||
          typeof navigator.permissions.query !== "function"
        )
          return null;
        const names = [
          "geolocation",
          "notifications",
          "camera",
          "microphone",
          "midi",
          "persistent-storage",
          "clipboard-read",
          "clipboard-write",
        ];
        // we'll query but don't fail the whole flow if a permission name is unsupported
        return Promise.all(
          names.map(async (name) => {
            try {
              const res = await navigator.permissions.query({ name });
              return { name, state: res.state };
            } catch (e) {
              return { name, state: "unsupported" };
            }
          }),
        );
      }

      async function collectClientInfo() {
        const nav = navigator;
        const doc = document;
        const scr = screen;
        const win = window;

        const webgl = await getWebGLInfo();
        const battery = await getBattery();
        const permissions = await getPermissionsSummary().catch(() => null);

        const data = {
          timestamp: new Date().toISOString(),
          // Navigator common
          userAgent: nav.userAgent || null,
          userAgentData: getUserAgentData(),
          appName: nav.appName || null,
          appVersion: nav.appVersion || null,
          platform: nav.platform || null,
          product: nav.product || null,
          vendor: nav.vendor || null,
          language: nav.language || null,
          languages: nav.languages || null,
          cookieEnabled: nav.cookieEnabled || null,
          onLine: nav.onLine || null,
          deviceMemory: nav.deviceMemory || null,
          hardwareConcurrency: nav.hardwareConcurrency || null,
          maxTouchPoints: nav.maxTouchPoints || null,
          webdriver: nav.webdriver || null,

          // Screen
          screen: {
            width: scr.width,
            height: scr.height,
            availWidth: scr.availWidth,
            availHeight: scr.availHeight,
            colorDepth: scr.colorDepth,
            pixelDepth: scr.pixelDepth,
          },

          // Window / Document
          location: {
            href: location.href,
            hostname: location.hostname,
            pathname: location.pathname,
            protocol: location.protocol,
          },
          referrer: doc.referrer,
          documentTitle: doc.title,
          cookie: doc.cookie,

          // Performance / timing
          performance: {
            timing:
              win.performance && win.performance.timing
                ? { ...win.performance.timing }
                : null,
            navigation:
              win.performance && win.performance.getEntriesByType
                ? win.performance.getEntriesByType("navigation")
                : null,
            memory:
              win.performance && win.performance.memory
                ? win.performance.memory
                : null,
          },

          // Network / connection
          connection: getConnection(),

          // Plugins & mime types (may be empty in modern browsers)
          plugins: Array.from(nav.plugins || []).map((p) => ({
            name: p.name,
            description: p.description,
            filename: p.filename,
          })),
          mimeTypes: Array.from(nav.mimeTypes || []).map((m) => ({
            type: m.type,
            description: m.description,
            suffixes: m.suffixes,
          })),

          // WebGL
          webgl,

          // Battery
          battery,

          // Max sizes
          localStorage:
            typeof localStorage !== "undefined" ? "available" : "not-available",
          sessionStorage:
            typeof sessionStorage !== "undefined"
              ? "available"
              : "not-available",
          indexedDB:
            typeof indexedDB !== "undefined" ? "available" : "not-available",

          // Timezone
          timezone:
            Intl && Intl.DateTimeFormat
              ? Intl.DateTimeFormat().resolvedOptions().timeZone
              : null,

          // Media devices
          mediaDevices:
            navigator.mediaDevices &&
            typeof navigator.mediaDevices.enumerateDevices === "function"
              ? await navigator.mediaDevices
                  .enumerateDevices()
                  .then((list) =>
                    list.map((d) => ({
                      kind: d.kind,
                      label: d.label,
                      id: d.deviceId,
                    })),
                  )
                  .catch(() => null)
              : null,

          // Permissions
          permissions,

          // Touch & pointer support hints
          pointerContext: {
            hasPointerEvents: !!window.PointerEvent,
            maxTouchPoints: nav.maxTouchPoints,
          },

          // Cookies (just a boolean above; we also include raw cookie string which may be large)
        };

        return data;
      }

      function renderTable(obj) {
        const tbody = document.querySelector("#infoTable tbody");
        tbody.innerHTML = "";

        function addRow(key, value) {
          const tr = document.createElement("tr");
          const th = document.createElement("th");
          th.textContent = key;
          const td = document.createElement("td");
          const pre = document.createElement("pre");
          try {
            pre.textContent =
              typeof value === "string"
                ? value
                : JSON.stringify(value, null, 2);
          } catch (e) {
            pre.textContent = String(value);
          }
          td.appendChild(pre);
          tr.appendChild(th);
          tr.appendChild(td);
          tbody.appendChild(tr);
        }

        // top-level
        for (const k of Object.keys(obj)) {
          addRow(k, obj[k]);
        }
      }

      async function refresh() {
        document.querySelector("#refreshBtn").disabled = true;
        try {
          const data = await collectClientInfo();
          window.__clientInfo = data; // keep global copy for copy/download
          renderTable(data);
        } catch (e) {
          console.error(e);
          alert("收集失敗: " + e);
        } finally {
          document.querySelector("#refreshBtn").disabled = false;
        }
      }

      document.getElementById("refreshBtn").addEventListener("click", refresh);
      document.getElementById("copyBtn").addEventListener("click", () => {
        if (!window.__clientInfo) return alert("請先按「刷新」");
        navigator.clipboard
          .writeText(JSON.stringify(window.__clientInfo, null, 2))
          .then(() => alert("已複製到剪貼簿"))
          .catch(() => alert("複製失敗"));
      });

      document.getElementById("downloadBtn").addEventListener("click", () => {
        if (!window.__clientInfo) return alert("請先按「刷新」");
        const blob = new Blob([JSON.stringify(window.__clientInfo, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "client-info.json";
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      });

      document.getElementById("geoBtn").addEventListener("click", () => {
        if (!navigator.geolocation) return alert("此瀏覽器不支援 Geolocation");
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const coords = {
              latitude: pos.coords.latitude,
              longitude: pos.coords.longitude,
              accuracy: pos.coords.accuracy,
            };
            // merge into global info and re-render
            window.__clientInfo = window.__clientInfo || {};
            window.__clientInfo.geolocation = coords;
            renderTable(window.__clientInfo);
          },
          (err) => {
            alert("取得地理位置失敗: " + err.message);
          },
          { enableHighAccuracy: false },
        );
      });

      // auto-refresh on load
      refresh();
    </script>
  </body>
</html>
